/**
 * Authentication Manager
 * Maneja autenticaci√≥n basada en cookies seguras
 */

if (typeof window.AuthManager === 'undefined') {
class AuthManager {
    constructor() {
        // Usar el proxy del frontend para que las cookies se manejen correctamente
        this.client = new EndpointTestClient(window.location.origin + '/proxy');
    }

    /**
     * Verifica si el usuario est√° autenticado
     */
    async isAuthenticated() {
        try {
            // Verificar si tenemos datos de usuario
            if (!window.currentUser) {
                //////console.log('‚ùå No hay datos de usuario');
                return false;
            }
            
            // Verificar si la sesi√≥n es v√°lida haciendo una petici√≥n al backend
            // Las cookies se env√≠an autom√°ticamente
            const response = await fetch('/proxy/health', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include'
            });
            
            const isValid = response.ok;
            if (!isValid) {
                ////console.log('‚ùå Sesi√≥n inv√°lida o expirada');
                this.clearStoredAuth();
            }
            
            return isValid;
        } catch (error) {
            ////console.error('‚ùå Error verificando autenticaci√≥n:', error);
            return false;
        }
    }

    /**
     * Obtiene el valor de una cookie
     */
    getCookie(name) {
        const cookies = document.cookie.split(';');
        for (let cookie of cookies) {
            const [cookieName, cookieValue] = cookie.trim().split('=');
            if (cookieName === name) {
                return cookieValue;
            }
        }
        return null;
    }

    /**
     * Obtiene el token almacenado desde cookie
     */
    getStoredToken() {
        // El token viene en cookie segura, no necesitamos acceder a √©l directamente
        // Solo verificamos si tenemos datos de usuario
        return window.currentUser ? 'cookie_auth' : null;
    }
    
    /**
     * Obtiene los datos del usuario almacenados
     */
    getStoredUser() {
        return window.currentUser || null;
    }
    
    /**
     * Limpia todos los datos de autenticaci√≥n almacenados
     */
    clearStoredAuth() {
        ////console.log('üßπ Limpiando datos de autenticaci√≥n almacenados');
        
        // Limpiar variables globales
        delete window.currentUser;
    }
    
    /**
     * Sincroniza sesi√≥n con Flask
     */
    async syncSession(user) {
        try {
            //console.log('üîÑ Sincronizando sesi√≥n con Flask:', user);
            const response = await fetch('/api/sync-session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',  // Asegurar que las cookies se env√≠an
                body: JSON.stringify({ user })
            });
            
            const result = await response.json();
            if (response.ok && result.success) {
                //console.log('‚úÖ Sesi√≥n Flask sincronizada');
                return true;
            } else {
                //console.error('‚ùå Error sincronizando sesi√≥n:', result.error);
                return false;
            }
        } catch (error) {
            //console.error('‚ùå Error de conexi√≥n en sync:', error);
            return false;
        }
    }

    /**
     * Realiza login del usuario
     */
    async login(usuario, password) {
        try {
            //console.log('üöÄ Iniciando login para:', usuario);
            const response = await this.client.login(usuario, password);
            //console.log('üåê Respuesta del servidor:', response.status, response.statusText);
            
            const result = await response.json();
            //console.log('üìù Datos de respuesta:', result);
            
            if (response.ok && result.success) {
                //console.log('‚úÖ Login exitoso - almacenando token y datos de usuario');
                
                // El token viene en cookie segura, no en la respuesta JSON
                // Almacenar datos del usuario
                const userData = result.data || result.user;
                if (userData) {
                    window.currentUser = userData;
                }
                
                // Sincronizar sesi√≥n con Flask (cookie se env√≠a autom√°ticamente)
                const syncSuccess = await this.syncSession(userData);
                if (syncSuccess) {
                    return { success: true, user: userData };
                } else {
                    return { success: false, errors: ['Error sincronizando sesi√≥n'] };
                }
            } else {
                //console.error('‚ùå Error en login:', result.errors || result.message);
                return { success: false, errors: result.errors || [result.message] || ['Error de autenticaci√≥n'] };
            }
        } catch (error) {
            //console.error('‚ùå Error de conexi√≥n:', error);
            return { success: false, errors: ['Error de conexi√≥n'] };
        }
    }

    /**
     * Realiza logout del usuario
     */
    async logout() {
        try {
            const response = await this.client.logout();
            const result = await response.json();
            
            if (response.ok && result.success) {
                //console.log('‚úÖ Logout exitoso');
                // Limpiar datos de autenticaci√≥n
                this.clearStoredAuth();
                
                // Redirigir al login despu√©s del logout
                setTimeout(() => {
                    window.location.href = '/login';
                }, 500);
                return { success: true };
            } else {
                //console.error('‚ùå Error en logout:', result.errors);
                return { success: false, errors: result.errors || ['Error al cerrar sesi√≥n'] };
            }
        } catch (error) {
            //console.error('‚ùå Error de conexi√≥n:', error);
            // Limpiar datos locales a√∫n si hay error de conexi√≥n
            this.clearStoredAuth();
            return { success: false, errors: ['Error de conexi√≥n'] };
        }
    }

    /**
     * Redirige al usuario al login si no est√° autenticado
     */
    requireAuth() {
        if (!this.isAuthenticated()) {
            this.redirectToLogin();
            return false;
        }
        return true;
    }

    /**
     * Redirige al login
     */
    redirectToLogin() {
        //console.log('üîÑ Redirigiendo al login...');
        window.location.href = '/login';
    }

    /**
     * Maneja errores de autenticaci√≥n
     */
    handleAuthError(response) {
        if (response.status === 401) {
            //console.warn('üö´ Token expirado o inv√°lido');
            this.showMessage('Sesi√≥n expirada. Redirigiendo al login...', 'error');
            setTimeout(() => {
                this.redirectToLogin();
            }, 2000);
        }
    }

    /**
     * Muestra mensajes al usuario
     */
    showMessage(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `auth-notification fixed top-4 right-4 p-4 rounded-lg text-white max-w-sm ${
            type === 'error' ? 'bg-red-500' : 
            type === 'success' ? 'bg-green-500' : 
            'bg-blue-500'
        }`;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        // Animaci√≥n de entrada
        notification.style.transform = 'translateX(100%)';
        notification.style.transition = 'transform 0.3s ease-in-out';
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 10);
        
        // Remover despu√©s de 5 segundos
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 5000);
    }

    /**
     * Inicializa botones de logout
     */
    initializeLogoutButtons() {
        const logoutButtons = document.querySelectorAll('[data-logout]');
        logoutButtons.forEach(button => {
            button.addEventListener('click', async (e) => {
                e.preventDefault();
                
                // Mostrar confirmaci√≥n
                if (confirm('¬øEst√°s seguro de que deseas cerrar sesi√≥n?')) {
                    this.showMessage('Cerrando sesi√≥n...', 'info');
                    const result = await this.logout();
                    
                    if (!result.success) {
                        this.showMessage('Error al cerrar sesi√≥n', 'error');
                    }
                }
            });
        });
    }

    /**
     * Verifica autenticaci√≥n con el backend
     */
    async verifyAuthWithBackend() {
        try {
            // Hacer una petici√≥n simple para verificar si las cookies funcionan
            const response = await this.client._request('GET', '/health');
            return response.ok;
        } catch (error) {
            //console.error('Error verificando autenticaci√≥n:', error);
            return false;
        }
    }

    /**
     * Test de conectividad a trav√©s del proxy
     */
    async testConnection() {
        try {
            //console.log('üìå Probando conexi√≥n al backend a trav√©s del proxy...');
            const response = await fetch('/proxy/health', {
                method: 'GET',
                credentials: 'include'
            });
            //console.log('üåê Respuesta de conexi√≥n:', response.status, response.statusText);
            if (response.ok) {
                const data = await response.json();
                //console.log('üìù Datos de health:', data);
            }
            return response.ok;
        } catch (error) {
            //console.error('‚ùå Error de conexi√≥n:', error);
            return false;
        }
    }

    /**
     * Inicializa el manejador de autenticaci√≥n
     */
    async init() {
        this.initializeLogoutButtons();
        
        // Probar conexi√≥n al backend
        const connected = await this.testConnection();
        if (connected) {
            //console.log('‚úÖ AuthManager inicializado - Backend conectado');
        } else {
            //console.warn('‚ö†Ô∏è AuthManager inicializado - Backend NO conectado');
        }
    }
}

// Hacer disponible globalmente
window.AuthManager = AuthManager;

// Auto-inicializar cuando el DOM est√© listo
document.addEventListener('DOMContentLoaded', () => {
    if (!window.authManager) {
        window.authManager = new AuthManager();
        window.authManager.init();
    }
});
}
